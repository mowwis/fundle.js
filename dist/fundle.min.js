class Model extends EventTarget{static fields={};static instanceCache=new Map;static classEventTarget=new EventTarget;fieldChanges={};get changeDelta(){return Object.entries(this.fieldChanges).reduce((t,[e,s])=>(t[e]=s.newValue,t),{})}constructor(t={}){super(),this.initializeFields();const e=t[this.constructor.primaryField];if(e&&this.constructor.instanceCache.has(e)){const s=this.constructor.instanceCache.get(e);return s.assign(t),s}this.assign(t)}initializeFields(){Object.keys(this.constructor.fields).forEach(t=>{const e=`_${t}`;this[e]=void 0,Object.defineProperty(this,t,{get(){return this[e]},set(s){const n=this[e];s!==n&&(this[e]=s,this.fieldChanges[t]?this.fieldChanges[t].newValue=s:this.fieldChanges[t]={oldValue:n,newValue:s})},enumerable:!0,configurable:!0})})}async save(){let t}revert(...t){Object.keys(this.fieldChanges).length&&(Object.entries(this.fieldChanges).forEach(([e,s])=>{(0==t.length||t.includes(e))&&(this[e]=s.oldValue,delete this.fieldChanges[e])}),this.dispatchEvent(ModelEvent.change(this,this.changeDelta)))}async delete(){if(!this.primaryKey)return;this.constructor.instanceCache.delete(this.primaryKey);const t=ModelEvent.delete(this);this.dispatchEvent(t),this.constructor.dispatchEvent(t)}assign(t={}){Object.entries(this.constructor.fields).forEach(([e,{type:s}])=>{e in t&&(this[e]=this.constructor.castFieldValue(t[e],s))});const e=t[this.constructor.primaryField];e&&!this.constructor.instanceCache.has(e)&&(this.constructor.instanceCache.set(e,this),this.constructor.dispatchEvent(ModelEvent.new(this))),Object.keys(this.fieldChanges).length&&this.dispatchEvent(ModelEvent.change(this,this.changeDelta)),this.fieldChanges={}}get primaryKey(){return this[this.constructor.primaryField]}static get primaryField(){const t=Object.keys(this.fields).find(t=>this.fields[t].primary_key);if(t)return t;if("id"in this.fields)return"id";throw new Error("Model must have a primary key or 'id' field defined.")}static dispatchEvent(t){this.classEventTarget.dispatchEvent(t)}static addEventListener(t,e){this.classEventTarget.addEventListener(t,e)}static removeEventListener(t,e){this.classEventTarget.removeEventListener(t,e)}static castFieldValue(t,e){if(null==t)return t;switch(e){case Date:return new Date(t);case Number:case String:case Boolean:return e(t);default:return t}}toJSON(){const t={};return Object.keys(this.constructor.fields).forEach(e=>{const s=this[e];null!=s&&(t[e]=s instanceof Date?s.toISOString():s)}),t}}class ModelEvent extends CustomEvent{static NEW="new";static CHANGE="change";static DELETE="delete";constructor(t,e){const s=[ModelEvent.NEW,ModelEvent.CHANGE,ModelEvent.DELETE];if(!s.includes(t))throw new Error(`Invalid event type: ${t}. Valid types are ${s.join(", ")}.`);super(t,{detail:e,bubbles:!0})}static new(t){return new ModelEvent(ModelEvent.NEW,t)}static delete(t){return new ModelEvent(ModelEvent.DELETE,t)}static change(t,e){return new ModelEvent(ModelEvent.CHANGE,{target:t,delta:e})}}class Templater{static clone(t){if("string"==typeof t&&(t=document.querySelector(t)),!(t&&t instanceof HTMLTemplateElement))throw new Error(`Templater: No valid HTMLTemplateElement found for selector/input: ${t}`);return t.content.cloneNode(!0)}static bind(t,e){const s=e=>":this"===e.trim()?[t]:(e.trim().startsWith(":this")&&(e=e.replace(":this","")),t.querySelectorAll(e));Object.entries(e).forEach(([t,e])=>{t.split(/,(?![^(]*\))/g).map(t=>t.trim()).forEach(t=>{const n=t.match(/^(.*?)::([a-zA-Z]+)\s*(.*)$/);if(n){const[,t,i,r]=n,a=[t,r].join(" "),c=s(t);c.length>0?c.forEach(t=>{const n=s(a)[0]||t;t.removeEventListener(i,t=>e(n,t)),t.addEventListener(i,t=>e(n,t))}):console.warn(`Templater: Event target element(s) not found for base selector: "${t}"`)}else{const n=s(t);n.length>0?n.forEach(t=>e(t)):console.warn(`Templater: Data binding target element(s) not found for selector: "${t}"`)}})})}}class Router{static routes=[];static currentRoute=null;static route(t,e){this.routes.push({path:t,callback:e})}static navigate(t){const e=this.matchRoute(t||window.location.pathname);e||this.go("/",replace=!0),this.currentRoute=e,e.callback(e.params,e.queryParams)}static matchRoute(t){for(const e of this.routes){const s=this.matchPath(t,e.path);if(s)return{...e,params:s.params,queryParams:s.queryParams}}return null}static matchPath(t,e){const[s,n]=t.split("?"),i=new URLSearchParams(n),r=s.split("/").filter(Boolean),a=e.split("/").filter(Boolean);if(r.length!==a.length)return null;const c={};for(let t=0;t<r.length;t++)if(a[t].startsWith(":")){c[a[t].slice(1)]=r[t]}else if(r[t]!==a[t])return null;return{params:c,queryParams:i}}static go(t,e=!1){e?history.replaceState({},"",t):history.pushState({},"",t),this.navigate(t)}}window.addEventListener("popstate",()=>Router.navigate(location.pathname));class API{static baseUrl="/api";static set baseUrl(t){this.baseUrl=t}static async request(t,e={}){var s=(t.startsWith("/")?this.baseUrl:"")+t;["DELETE","PATCH"].includes(e.method)||(s=s.endsWith("/")?s:s+"/");const n=await fetch(s,{headers:{"Content-Type":"application/json"},...e});if(!n.ok)throw new Error(`API Error: ${n.status} - ${await n.text()}`);return n.json()}static get(t){return this.request(t)}static post(t,e){return this.request(t,{method:"POST",body:JSON.stringify(e)})}static patch(t,e){return this.request(t,{method:"PATCH",body:JSON.stringify(e)})}static delete(t){return this.request(t,{method:"DELETE"})}static postFile(t,e){return this.request(t,{method:"POST",body:e,headers:{}})}}